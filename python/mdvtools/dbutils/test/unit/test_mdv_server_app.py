import unittest
from unittest.mock import patch, MagicMock, mock_open
import os
import tempfile
import shutil
import json
from sqlalchemy.exc import OperationalError
from flask import Flask
from mdvtools.dbutils.mdv_server_app import (
    wait_for_database, 
    create_flask_app, 
    read_secret, 
    load_config, 
    create_base_directory, 
    tables_exist, 
    is_valid_mdv_project,
    serve_projects_from_db,
    serve_projects_from_filesystem
)
from sqlalchemy.sql.elements import TextClause

# NOTE: this code was generated by an LLM in cursor and has not been carefully reviewed.


class TestWaitForDatabase(unittest.TestCase):
    """Test cases for the wait_for_database function."""

    def setUp(self):
        """Set up test fixtures."""
        self.app = Flask(__name__)
        self.app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
        
        # Mock environment variables
        self.env_patcher = patch.dict(os.environ, {
            'DB_USER': 'test_user',
            'DB_PASSWORD': 'test_password',
            'DB_HOST': 'test_host',
            'DB_NAME': 'test_db'
        })
        self.env_patcher.start()

    def tearDown(self):
        """Clean up after tests."""
        self.env_patcher.stop()

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_wait_for_database_success_first_attempt(self, mock_db, mock_create_engine):
        """Test successful database connection on first attempt."""
        # Mock the postgres engine
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = True  # Database exists
        
        # Mock the Flask-SQLAlchemy engine
        mock_flask_engine = MagicMock()
        mock_flask_connection = MagicMock()
        mock_flask_engine.connect.return_value = mock_flask_connection
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Call the function
        wait_for_database(self.app)
        
        # Verify postgres engine was created and used correctly
        mock_create_engine.assert_called_once_with(
            'postgresql://test_user:test_password@test_host/postgres',
            isolation_level="AUTOCOMMIT"
        )
        mock_postgres_engine.connect.assert_called_once()
        mock_postgres_connection.execute.assert_called_once()
        mock_postgres_engine.dispose.assert_called_once()
        
        # Verify Flask-SQLAlchemy engine was used for test connection
        mock_flask_engine.connect.assert_called_once()
        mock_flask_connection.execute.assert_called_once()
        mock_flask_connection.close.assert_called_once()
        
        # Verify config was updated
        expected_uri = 'postgresql://test_user:test_password@test_host/test_db'
        self.assertEqual(self.app.config['SQLALCHEMY_DATABASE_URI'], expected_uri)

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_wait_for_database_creates_database_if_not_exists(self, mock_db, mock_create_engine):
        """Test that database is created if it doesn't exist."""
        # Mock the postgres engine
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = False  # Database doesn't exist
        
        # Mock the Flask-SQLAlchemy engine
        mock_flask_engine = MagicMock()
        mock_flask_connection = MagicMock()
        mock_flask_engine.connect.return_value = mock_flask_connection
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Call the function
        wait_for_database(self.app)
        
        # Verify database creation was attempted - check that execute was called with CREATE DATABASE
        create_db_calls = [call for call in mock_postgres_connection.execute.call_args_list 
            if isinstance(call[0][0], TextClause) and 'CREATE DATABASE' in str(call[0][0])]
        self.assertTrue(len(create_db_calls) > 0, "CREATE DATABASE call not found")

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    @patch('time.sleep')
    def test_wait_for_database_retries_on_operational_error(self, mock_sleep, mock_db, mock_create_engine):
        """Test that function retries on OperationalError."""
        # Mock the postgres engine
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = True
        
        # Mock the Flask-SQLAlchemy engine to fail first, then succeed
        mock_flask_engine = MagicMock()
        mock_flask_connection = MagicMock()
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Make the first connect call fail, then succeed
        mock_flask_engine.connect.side_effect = [OperationalError("Connection failed", {}, Exception("Original error")), mock_flask_connection]
        
        # Call the function
        wait_for_database(self.app)
        
        # Verify sleep was called
        mock_sleep.assert_called_once_with(5)
        
        # Verify connect was called twice (once failed, once succeeded)
        self.assertEqual(mock_flask_engine.connect.call_count, 2)

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    @patch('time.sleep')
    def test_wait_for_database_timeout_after_max_retries(self, mock_sleep, mock_db, mock_create_engine):
        """Test that function raises TimeoutError after max retries."""
        # Mock the postgres engine
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = True
        
        # Mock the Flask-SQLAlchemy engine to always fail
        mock_flask_engine = MagicMock()
        mock_flask_engine.connect.side_effect = OperationalError("Connection failed", {}, Exception("Original error"))
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Call the function and expect TimeoutError
        with self.assertRaises(TimeoutError) as context:
            wait_for_database(self.app)
        
        # Verify the error message
        self.assertIn("Database did not become available in time", str(context.exception))
        
        # Verify sleep was called the expected number of times (30 retries)
        self.assertEqual(mock_sleep.call_count, 30)

    def test_wait_for_database_missing_db_name(self):
        """Test that function raises ValueError when DB_NAME is not set."""
        # Remove DB_NAME from environment
        with patch.dict(os.environ, {}, clear=True):
            with self.assertRaises(ValueError) as context:
                wait_for_database(self.app)
            
            self.assertIn("DB_NAME environment variable is not set", str(context.exception))

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_wait_for_database_uri_construction_efficiency(self, mock_db, mock_create_engine):
        """Test that URI is constructed only once and config is set once."""
        # Mock the engines
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = True
        
        mock_flask_engine = MagicMock()
        mock_flask_connection = MagicMock()
        mock_flask_engine.connect.return_value = mock_flask_connection
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Call the function
        wait_for_database(self.app)
        
        # Verify create_engine was called only once (for postgres connection)
        mock_create_engine.assert_called_once()
        
        # Verify the config was set to the expected URI
        expected_uri = 'postgresql://test_user:test_password@test_host/test_db'
        self.assertEqual(self.app.config['SQLALCHEMY_DATABASE_URI'], expected_uri)


class TestReadSecret(unittest.TestCase):
    """Test cases for the read_secret function."""

    @patch('builtins.open', new_callable=mock_open, read_data='secret_value')
    def test_read_secret_success(self, mock_file):
        """Test successful reading of a secret file."""
        result = read_secret('test_secret')
        self.assertEqual(result, 'secret_value')
        mock_file.assert_called_once_with('/run/secrets/test_secret', 'r')

    @patch('builtins.open', side_effect=FileNotFoundError('Secret not found'))
    def test_read_secret_file_not_found(self, mock_file):
        """Test that FileNotFoundError is raised when secret file doesn't exist."""
        with self.assertRaises(FileNotFoundError):
            read_secret('nonexistent_secret')
        mock_file.assert_called_once_with('/run/secrets/nonexistent_secret', 'r')

    @patch('builtins.open', new_callable=mock_open, read_data='  secret_with_whitespace  \n')
    def test_read_secret_strips_whitespace(self, mock_file):
        """Test that whitespace is stripped from the secret value."""
        result = read_secret('test_secret')
        self.assertEqual(result, 'secret_with_whitespace')


class TestLoadConfig(unittest.TestCase):
    """Test cases for the load_config function."""

    def setUp(self):
        """Set up test fixtures."""
        self.app = Flask(__name__)

    @patch('builtins.open', new_callable=mock_open, read_data='{"track_modifications": true, "upload_folder": "/uploads", "projects_base_dir": "/projects", "db_container": "localhost"}')
    @patch('os.path.dirname')
    @patch('os.path.abspath')
    def test_load_config_success(self, mock_abspath, mock_dirname, mock_file):
        """Test successful loading of configuration."""
        mock_abspath.return_value = '/test/path'
        mock_dirname.return_value = '/test'
        
        load_config(self.app)
        
        self.assertEqual(self.app.config['SQLALCHEMY_TRACK_MODIFICATIONS'], True)
        self.assertEqual(self.app.config['upload_folder'], '/uploads')
        self.assertEqual(self.app.config['projects_base_dir'], '/projects')
        self.assertEqual(self.app.config['db_host'], 'localhost')

    @patch('builtins.open', side_effect=FileNotFoundError('Config file not found'))
    @patch('os.path.dirname')
    @patch('os.path.abspath')
    def test_load_config_file_not_found(self, mock_abspath, mock_dirname, mock_file):
        """Test that FileNotFoundError is raised when config file doesn't exist."""
        mock_abspath.return_value = '/test/path'
        mock_dirname.return_value = '/test'
        
        with self.assertRaises(FileNotFoundError):
            load_config(self.app)

    @patch('builtins.open', new_callable=mock_open, read_data='{"invalid": json}')
    @patch('os.path.dirname')
    @patch('os.path.abspath')
    def test_load_config_invalid_json(self, mock_abspath, mock_dirname, mock_file):
        """Test that JSON decode error is handled."""
        mock_abspath.return_value = '/test/path'
        mock_dirname.return_value = '/test'
        
        with self.assertRaises(json.JSONDecodeError):
            load_config(self.app)

    @patch('builtins.open', new_callable=mock_open, read_data='{"track_modifications": false}')
    @patch('os.path.dirname')
    @patch('os.path.abspath')
    @patch.dict(os.environ, {
        'DB_USER': 'test_user',
        'DB_PASSWORD': 'test_password',
        'DB_NAME': 'test_db',
        'DB_HOST': 'test_host'
    })
    def test_load_config_with_environment_variables(self, mock_abspath, mock_dirname, mock_file):
        """Test loading config with environment variables."""
        mock_abspath.return_value = '/test/path'
        mock_dirname.return_value = '/test'
        
        load_config(self.app)
        
        expected_uri = 'postgresql://test_user:test_password@test_host/test_db'
        self.assertEqual(self.app.config['SQLALCHEMY_DATABASE_URI'], expected_uri)

    @patch('builtins.open', new_callable=mock_open, read_data='{"track_modifications": false, "db_container": "test_host"}')
    @patch('os.path.dirname')
    @patch('os.path.abspath')
    @patch('mdvtools.dbutils.mdv_server_app.read_secret')
    def test_load_config_with_secrets(self, mock_read_secret, mock_abspath, mock_dirname, mock_file):
        """Test loading config with Docker secrets."""
        mock_abspath.return_value = '/test/path'
        mock_dirname.return_value = '/test'
        mock_read_secret.side_effect = ['secret_user', 'secret_password', 'secret_db']
        
        # Clear all environment variables to ensure secrets are used
        with patch.dict(os.environ, {}, clear=True):
            load_config(self.app)
        
        expected_uri = 'postgresql://secret_user:secret_password@test_host/secret_db'
        self.assertEqual(self.app.config['SQLALCHEMY_DATABASE_URI'], expected_uri)

    @patch('builtins.open', new_callable=mock_open, read_data='{"track_modifications": false}')
    @patch('os.path.dirname')
    @patch('os.path.abspath')
    def test_load_config_test_environment(self, mock_abspath, mock_dirname, mock_file):
        """Test loading config for test environment."""
        mock_abspath.return_value = '/test/path'
        mock_dirname.return_value = '/test'
        
        load_config(self.app, config_name='test')
        
        self.assertEqual(self.app.config['PREFERRED_URL_SCHEME'], 'http')
        self.assertEqual(self.app.config['SQLALCHEMY_DATABASE_URI'], 'sqlite:///:memory:')


class TestCreateBaseDirectory(unittest.TestCase):
    """Test cases for the create_base_directory function."""

    def setUp(self):
        """Set up test fixtures."""
        self.app = Flask(__name__)
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Clean up after tests."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_create_base_directory_creates_new_directory(self):
        """Test creating a new base directory."""
        new_dir = os.path.join(self.temp_dir, 'new_mdv_dir')
        self.app.config['projects_base_dir'] = new_dir
        
        create_base_directory(self.app)
        
        self.assertTrue(os.path.exists(new_dir))
        self.assertTrue(os.path.isdir(new_dir))

    def test_create_base_directory_existing_directory(self):
        """Test handling of existing directory."""
        existing_dir = os.path.join(self.temp_dir, 'existing_mdv_dir')
        os.makedirs(existing_dir)
        self.app.config['projects_base_dir'] = existing_dir
        
        # Should not raise an exception
        create_base_directory(self.app)
        
        self.assertTrue(os.path.exists(existing_dir))

    def test_create_base_directory_default_value(self):
        """Test using default value when projects_base_dir is not set."""
        # Remove the config value
        if 'projects_base_dir' in self.app.config:
            del self.app.config['projects_base_dir']
        
        # Change to temp directory for testing
        original_cwd = os.getcwd()
        os.chdir(self.temp_dir)
        
        try:
            create_base_directory(self.app)
            self.assertTrue(os.path.exists('mdv'))
        finally:
            os.chdir(original_cwd)
            # Clean up
            if os.path.exists(os.path.join(self.temp_dir, 'mdv')):
                shutil.rmtree(os.path.join(self.temp_dir, 'mdv'))

    def test_create_base_directory_permission_error(self):
        """Test handling of permission errors."""
        # Create a read-only directory
        read_only_dir = os.path.join(self.temp_dir, 'read_only')
        os.makedirs(read_only_dir)
        os.chmod(read_only_dir, 0o444)  # Read-only
        
        self.app.config['projects_base_dir'] = os.path.join(read_only_dir, 'new_dir')
        
        with self.assertRaises(Exception):
            create_base_directory(self.app)


class TestTablesExist(unittest.TestCase):
    """Test cases for the tables_exist function."""

    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_tables_exist_success(self, mock_db):
        """Test successful table inspection."""
        mock_inspector = MagicMock()
        mock_inspector.get_table_names.return_value = ['table1', 'table2', 'table3']
        mock_db.inspect.return_value = mock_inspector
        
        result = tables_exist()
        
        self.assertEqual(result, ['table1', 'table2', 'table3'])
        mock_db.inspect.assert_called_once_with(mock_db.engine)

    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_tables_exist_empty_result(self, mock_db):
        """Test table inspection with no tables."""
        mock_inspector = MagicMock()
        mock_inspector.get_table_names.return_value = []
        mock_db.inspect.return_value = mock_inspector
        
        result = tables_exist()
        
        self.assertEqual(result, [])


class TestIsValidMdvProject(unittest.TestCase):
    """Test cases for the is_valid_mdv_project function."""

    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Clean up after tests."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_is_valid_mdv_project_valid_project(self):
        """Test valid MDV project with all required files."""
        # Create required files
        for filename in ['views.json', 'state.json', 'datasources.json']:
            with open(os.path.join(self.temp_dir, filename), 'w') as f:
                f.write('{}')
        
        result = is_valid_mdv_project(self.temp_dir)
        self.assertTrue(result)

    def test_is_valid_mdv_project_missing_files(self):
        """Test invalid MDV project with missing files."""
        # Create only some required files
        with open(os.path.join(self.temp_dir, 'views.json'), 'w') as f:
            f.write('{}')
        with open(os.path.join(self.temp_dir, 'state.json'), 'w') as f:
            f.write('{}')
        # Missing datasources.json
        
        result = is_valid_mdv_project(self.temp_dir)
        self.assertFalse(result)

    def test_is_valid_mdv_project_not_directory(self):
        """Test with a file instead of directory."""
        file_path = os.path.join(self.temp_dir, 'not_a_dir')
        with open(file_path, 'w') as f:
            f.write('test')
        
        result = is_valid_mdv_project(file_path)
        self.assertFalse(result)

    def test_is_valid_mdv_project_nonexistent_path(self):
        """Test with nonexistent path."""
        nonexistent_path = os.path.join(self.temp_dir, 'nonexistent')
        
        result = is_valid_mdv_project(nonexistent_path)
        self.assertFalse(result)

    def test_is_valid_mdv_project_empty_directory(self):
        """Test with empty directory."""
        result = is_valid_mdv_project(self.temp_dir)
        self.assertFalse(result)


class TestServeProjectsFromDb(unittest.TestCase):
    """Test cases for the serve_projects_from_db function."""

    def setUp(self):
        """Set up test fixtures."""
        self.app = Flask(__name__)
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Clean up after tests."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    @patch('mdvtools.dbutils.mdv_server_app.Project')
    @patch('mdvtools.dbutils.mdv_server_app.MDVProject')
    @patch('os.path.exists')
    def test_serve_projects_from_db_success(self, mock_exists, mock_mdv_project, mock_project):
        """Test successful serving of projects from database."""
        # Mock project
        mock_project_instance = MagicMock()
        mock_project_instance.id = 1
        mock_project_instance.path = self.temp_dir
        mock_project_instance.is_deleted = False
        mock_project.query.all.return_value = [mock_project_instance]
        
        # Mock file system
        mock_exists.return_value = True
        
        # Mock MDVProject
        mock_mdv_instance = MagicMock()
        mock_mdv_project.return_value = mock_mdv_instance
        
        # Mock file walk
        with patch('os.walk') as mock_walk:
            mock_walk.return_value = [(self.temp_dir, [], ['test.txt'])]
            
            serve_projects_from_db(self.app)
            
            # Verify MDVProject was created and served
            mock_mdv_project.assert_called_once_with(dir=self.temp_dir, id='1', backend_db=True)
            mock_mdv_instance.set_editable.assert_called_once_with(True)
            mock_mdv_instance.serve.assert_called_once()

    @patch('mdvtools.dbutils.mdv_server_app.Project')
    @patch('os.path.exists')
    def test_serve_projects_from_db_deleted_project(self, mock_exists, mock_project):
        """Test handling of deleted projects."""
        # Mock deleted project
        mock_project_instance = MagicMock()
        mock_project_instance.id = 1
        mock_project_instance.is_deleted = True
        mock_project.query.all.return_value = [mock_project_instance]
        
        serve_projects_from_db(self.app)
        
        # Should not try to serve deleted projects
        mock_exists.assert_not_called()

    @patch('mdvtools.dbutils.mdv_server_app.Project')
    @patch('mdvtools.dbutils.mdv_server_app.MDVProject')
    @patch('os.path.exists')
    def test_serve_projects_from_db_missing_path(self, mock_exists, mock_mdv_project, mock_project):
        """Test handling of projects with missing paths."""
        # Mock project with missing path
        mock_project_instance = MagicMock()
        mock_project_instance.id = 1
        mock_project_instance.path = '/nonexistent/path'
        mock_project_instance.is_deleted = False
        mock_project.query.all.return_value = [mock_project_instance]
        
        mock_exists.return_value = False
        
        serve_projects_from_db(self.app)
        
        # Should handle missing paths gracefully
        mock_mdv_project.assert_not_called()

    @patch('mdvtools.dbutils.mdv_server_app.Project')
    @patch('mdvtools.dbutils.mdv_server_app.MDVProject')
    @patch('os.path.exists')
    def test_serve_projects_from_db_mdv_project_error(self, mock_exists, mock_mdv_project, mock_project):
        """Test handling of MDVProject creation errors."""
        # Mock project
        mock_project_instance = MagicMock()
        mock_project_instance.id = 1
        mock_project_instance.path = self.temp_dir
        mock_project_instance.is_deleted = False
        mock_project.query.all.return_value = [mock_project_instance]
        
        mock_exists.return_value = True
        
        # Mock MDVProject to raise exception
        mock_mdv_project.side_effect = Exception("MDVProject error")
        
        serve_projects_from_db(self.app)
        
        # Should handle errors gracefully and continue


class TestServeProjectsFromFilesystem(unittest.TestCase):
    """Test cases for the serve_projects_from_filesystem function."""

    def setUp(self):
        """Set up test fixtures."""
        self.app = Flask(__name__)
        self.temp_dir = tempfile.mkdtemp()
        self.app.config['projects_base_dir'] = self.temp_dir

    def tearDown(self):
        """Clean up after tests."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    @patch('mdvtools.dbutils.mdv_server_app.Project')
    @patch('mdvtools.dbutils.mdv_server_app.MDVProject')
    @patch('mdvtools.dbutils.mdv_server_app.ProjectService')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    @patch('os.listdir')
    @patch('os.path.isdir')
    @patch('os.path.exists')
    def test_serve_projects_from_filesystem_new_project(self, mock_exists, mock_isdir, mock_listdir, mock_db, mock_project_service, mock_mdv_project, mock_project):
        """Test creating and serving a new project from filesystem."""
        # Mock filesystem
        mock_listdir.return_value = ['project1']
        mock_isdir.return_value = True
        mock_exists.return_value = True
        
        # Mock database
        mock_project.query.with_entities.return_value.all.return_value = []
        mock_db.session.query.return_value.func.max.return_value.scalar.return_value = None
        
        # Mock project service
        mock_new_project = MagicMock()
        mock_new_project.id = 1
        mock_new_project.path = os.path.join(self.temp_dir, 'project1')
        mock_project_service.add_new_project.return_value = mock_new_project
        
        # Mock MDVProject
        mock_mdv_instance = MagicMock()
        mock_mdv_project.return_value = mock_mdv_instance
        
        # Mock file walk
        with patch('os.walk') as mock_walk:
            mock_walk.return_value = [(os.path.join(self.temp_dir, 'project1'), [], ['test.txt'])]
            
            serve_projects_from_filesystem(self.app, self.temp_dir)
            
            # Verify project was created and served
            mock_project_service.add_new_project.assert_called_once()
            mock_mdv_project.assert_called_once()
            mock_mdv_instance.serve.assert_called_once()

    @patch('mdvtools.dbutils.mdv_server_app.Project')
    @patch('mdvtools.dbutils.mdv_server_app.MDVProject')
    @patch('os.listdir')
    @patch('os.path.isdir')
    def test_serve_projects_from_filesystem_no_new_projects(self, mock_isdir, mock_listdir, mock_mdv_project, mock_project):
        """Test when no new projects exist in filesystem."""
        # Mock filesystem with no projects
        mock_listdir.return_value = []
        
        # Mock database with existing projects
        mock_project.query.with_entities.return_value.all.return_value = []
        
        serve_projects_from_filesystem(self.app, self.temp_dir)
        
        # Should handle empty filesystem gracefully
        mock_mdv_project.assert_not_called()

    @patch('mdvtools.dbutils.mdv_server_app.Project')
    @patch('mdvtools.dbutils.mdv_server_app.MDVProject')
    @patch('mdvtools.dbutils.mdv_server_app.ProjectService')
    @patch('os.listdir')
    @patch('os.path.isdir')
    @patch('os.path.exists')
    def test_serve_projects_from_filesystem_project_service_error(self, mock_exists, mock_isdir, mock_listdir, mock_project_service, mock_mdv_project, mock_project):
        """Test handling of ProjectService errors."""
        # Mock filesystem
        mock_listdir.return_value = ['project1']
        mock_isdir.return_value = True
        mock_exists.return_value = True
        
        # Mock database
        mock_project.query.with_entities.return_value.all.return_value = []
        
        # Mock project service to return None
        mock_project_service.add_new_project.return_value = None
        
        # Mock MDVProject
        mock_mdv_instance = MagicMock()
        mock_mdv_project.return_value = mock_mdv_instance
        
        # Mock database session query
        with patch('mdvtools.dbutils.mdv_server_app.db') as mock_db:
            mock_query = MagicMock()
            mock_query.func.max.return_value.scalar.return_value = None
            mock_db.session.query.return_value = mock_query
            
            with self.app.app_context():
                with self.assertRaises(ValueError):
                    serve_projects_from_filesystem(self.app, self.temp_dir)


class TestCreateFlaskApp(unittest.TestCase):
    """Test cases for the create_flask_app function."""

    @patch('mdvtools.dbutils.mdv_server_app.serve_projects_from_filesystem')
    @patch('mdvtools.dbutils.mdv_server_app.serve_projects_from_db')
    @patch('mdvtools.dbutils.mdv_server_app.register_routes')
    @patch('mdvtools.dbutils.mdv_server_app.ProjectBlueprint.register_app')
    @patch('mdvtools.dbutils.mdv_server_app.cache_user_projects')
    @patch('mdvtools.dbutils.mdv_server_app.wait_for_database')
    @patch('mdvtools.dbutils.mdv_server_app.load_config')
    @patch('mdvtools.dbutils.mdv_server_app.create_base_directory')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_create_flask_app_test_config(self, mock_db, mock_create_base_dir, mock_load_config, mock_wait_for_db, mock_cache_users, mock_register_app, mock_register_routes, mock_serve_db, mock_serve_fs):
        """Test app creation with test configuration."""
        app = create_flask_app(config_name='test')
        
        self.assertIsInstance(app, Flask)
        self.assertTrue(app.config['TESTING'])
        mock_wait_for_db.assert_not_called()

    @patch('mdvtools.dbutils.mdv_server_app.serve_projects_from_filesystem')
    @patch('mdvtools.dbutils.mdv_server_app.serve_projects_from_db')
    @patch('mdvtools.dbutils.mdv_server_app.register_routes')
    @patch('mdvtools.dbutils.mdv_server_app.ProjectBlueprint.register_app')
    @patch('mdvtools.dbutils.mdv_server_app.cache_user_projects')
    @patch('mdvtools.dbutils.mdv_server_app.wait_for_database')
    @patch('mdvtools.dbutils.mdv_server_app.load_config')
    @patch('mdvtools.dbutils.mdv_server_app.create_base_directory')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    @patch('mdvtools.dbutils.mdv_server_app.tables_exist')
    def test_create_flask_app_production_config(self, mock_tables_exist, mock_db, mock_create_base_dir, mock_load_config, mock_wait_for_db, mock_cache_users, mock_register_app, mock_register_routes, mock_serve_db, mock_serve_fs):
        """Test app creation with production configuration."""
        mock_tables_exist.return_value = True
        
        # We need to ensure the app has the required config for the auth provider.
        mock_load_config.side_effect = lambda app, *args: app.config.update({"DEFAULT_AUTH_METHOD": "dummy"})
        
        app = create_flask_app(config_name='production')

        self.assertIsInstance(app, Flask)
        mock_wait_for_db.assert_called_once()

    @patch('mdvtools.dbutils.mdv_server_app.load_config', side_effect=Exception("Config load failed"))
    def test_create_flask_app_config_error(self, mock_load_config):
        """Test create_flask_app with configuration error."""
        with self.assertRaises(Exception):
            create_flask_app()

    @patch('mdvtools.dbutils.mdv_server_app.load_config')
    @patch('mdvtools.dbutils.mdv_server_app.create_base_directory')
    def test_create_flask_app_base_directory_error(self, mock_create_base_dir, mock_load_config):
        """Test create_flask_app with base directory creation error."""
        mock_create_base_dir.side_effect = Exception("Directory error")
        
        with self.assertRaises(Exception):
            create_flask_app()

    @patch('mdvtools.dbutils.mdv_server_app.load_config')
    @patch('mdvtools.dbutils.mdv_server_app.create_base_directory')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_create_flask_app_db_init_error(self, mock_db, mock_create_base_dir, mock_load_config):
        """Test create_flask_app with database initialization error."""
        mock_db.init_app.side_effect = Exception("DB init error")
        
        with self.assertRaises(Exception):
            create_flask_app()


if __name__ == '__main__':
    unittest.main() 