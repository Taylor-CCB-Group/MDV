import unittest
from unittest.mock import patch, MagicMock, call
import os
from sqlalchemy.exc import OperationalError
from flask import Flask
from mdvtools.dbutils.mdv_server_app import wait_for_database, create_flask_app
from sqlalchemy.sql.elements import TextClause

# NOTE: this code was generated by an LLM in cursor and has not been carefully reviewed.

class TestWaitForDatabase(unittest.TestCase):
    """Test cases for the wait_for_database function."""

    def setUp(self):
        """Set up test fixtures."""
        self.app = Flask(__name__)
        self.app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
        
        # Mock environment variables
        self.env_patcher = patch.dict(os.environ, {
            'DB_USER': 'test_user',
            'DB_PASSWORD': 'test_password',
            'DB_HOST': 'test_host',
            'DB_NAME': 'test_db'
        })
        self.env_patcher.start()

    def tearDown(self):
        """Clean up after tests."""
        self.env_patcher.stop()

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_wait_for_database_success_first_attempt(self, mock_db, mock_create_engine):
        """Test successful database connection on first attempt."""
        # Mock the postgres engine
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = True  # Database exists
        
        # Mock the Flask-SQLAlchemy engine
        mock_flask_engine = MagicMock()
        mock_flask_connection = MagicMock()
        mock_flask_engine.connect.return_value = mock_flask_connection
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Call the function
        wait_for_database(self.app)
        
        # Verify postgres engine was created and used correctly
        mock_create_engine.assert_called_once_with(
            'postgresql://test_user:test_password@test_host/postgres',
            isolation_level="AUTOCOMMIT"
        )
        mock_postgres_engine.connect.assert_called_once()
        mock_postgres_connection.execute.assert_called_once()
        mock_postgres_engine.dispose.assert_called_once()
        
        # Verify Flask-SQLAlchemy engine was used for test connection
        mock_flask_engine.connect.assert_called_once()
        mock_flask_connection.execute.assert_called_once()
        mock_flask_connection.close.assert_called_once()
        
        # Verify config was updated
        expected_uri = 'postgresql://test_user:test_password@test_host/test_db'
        self.assertEqual(self.app.config['SQLALCHEMY_DATABASE_URI'], expected_uri)

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_wait_for_database_creates_database_if_not_exists(self, mock_db, mock_create_engine):
        """Test that database is created if it doesn't exist."""
        # Mock the postgres engine
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = False  # Database doesn't exist
        
        # Mock the Flask-SQLAlchemy engine
        mock_flask_engine = MagicMock()
        mock_flask_connection = MagicMock()
        mock_flask_engine.connect.return_value = mock_flask_connection
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Call the function
        wait_for_database(self.app)
        
        # Verify database creation was attempted - check that execute was called with CREATE DATABASE
        create_db_calls = [call for call in mock_postgres_connection.execute.call_args_list 
            if isinstance(call[0][0], TextClause) and 'CREATE DATABASE' in str(call[0][0])]
        self.assertTrue(len(create_db_calls) > 0, "CREATE DATABASE call not found")

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    @patch('time.sleep')
    def test_wait_for_database_retries_on_operational_error(self, mock_sleep, mock_db, mock_create_engine):
        """Test that function retries on OperationalError."""
        # Mock the postgres engine
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = True
        
        # Mock the Flask-SQLAlchemy engine to fail first, then succeed
        mock_flask_engine = MagicMock()
        mock_flask_connection = MagicMock()
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Make the first connect call fail, then succeed
        mock_flask_engine.connect.side_effect = [OperationalError("Connection failed", {}, Exception("Original error")), mock_flask_connection]
        
        # Call the function
        wait_for_database(self.app)
        
        # Verify sleep was called
        mock_sleep.assert_called_once_with(5)
        
        # Verify connect was called twice (once failed, once succeeded)
        self.assertEqual(mock_flask_engine.connect.call_count, 2)

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    @patch('time.sleep')
    def test_wait_for_database_timeout_after_max_retries(self, mock_sleep, mock_db, mock_create_engine):
        """Test that function raises TimeoutError after max retries."""
        # Mock the postgres engine
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = True
        
        # Mock the Flask-SQLAlchemy engine to always fail
        mock_flask_engine = MagicMock()
        mock_flask_engine.connect.side_effect = OperationalError("Connection failed", {}, Exception("Original error"))
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Call the function and expect TimeoutError
        with self.assertRaises(TimeoutError) as context:
            wait_for_database(self.app)
        
        # Verify the error message
        self.assertIn("Database did not become available in time", str(context.exception))
        
        # Verify sleep was called the expected number of times (30 retries)
        self.assertEqual(mock_sleep.call_count, 30)

    def test_wait_for_database_missing_db_name(self):
        """Test that function raises ValueError when DB_NAME is not set."""
        # Remove DB_NAME from environment
        with patch.dict(os.environ, {}, clear=True):
            with self.assertRaises(ValueError) as context:
                wait_for_database(self.app)
            
            self.assertIn("DB_NAME environment variable is not set", str(context.exception))

    @patch('mdvtools.dbutils.mdv_server_app.create_engine')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_wait_for_database_uri_construction_efficiency(self, mock_db, mock_create_engine):
        """Test that URI is constructed only once and config is set once."""
        # Mock the engines
        mock_postgres_engine = MagicMock()
        mock_postgres_connection = MagicMock()
        mock_postgres_engine.connect.return_value = mock_postgres_connection
        mock_postgres_connection.execute.return_value.scalar.return_value = True
        
        mock_flask_engine = MagicMock()
        mock_flask_connection = MagicMock()
        mock_flask_engine.connect.return_value = mock_flask_connection
        
        mock_create_engine.return_value = mock_postgres_engine
        mock_db.engine = mock_flask_engine
        
        # Call the function
        wait_for_database(self.app)
        
        # Verify create_engine was called only once (for postgres connection)
        mock_create_engine.assert_called_once()
        
        # Verify the config was set to the expected URI
        expected_uri = 'postgresql://test_user:test_password@test_host/test_db'
        self.assertEqual(self.app.config['SQLALCHEMY_DATABASE_URI'], expected_uri)


class TestCreateFlaskApp(unittest.TestCase):
    """Test cases for the create_flask_app function."""

    @patch('mdvtools.dbutils.mdv_server_app.wait_for_database')
    @patch('mdvtools.dbutils.mdv_server_app.load_config')
    @patch('mdvtools.dbutils.mdv_server_app.create_base_directory')
    @patch('mdvtools.dbutils.mdv_server_app.db')
    def test_create_flask_app_test_config(self, mock_db, mock_create_base_dir, mock_load_config, mock_wait_for_db):
        """Test create_flask_app with test configuration."""
        # Mock environment variables
        with patch.dict(os.environ, {}, clear=True):
            app = create_flask_app(config_name='test')
            
            # Verify test configuration was used
            mock_load_config.assert_called_once()
            # In test mode, wait_for_database should not be called
            mock_wait_for_db.assert_not_called()
            
            # Verify the app was created successfully
            self.assertIsNotNone(app)


if __name__ == '__main__':
    unittest.main() 