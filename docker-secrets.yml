services:
  mdv_app:
    build:
     context: .
     args:
      - GIT_COMMIT_DATE=${GIT_COMMIT_DATE}
      - GIT_BRANCH_NAME=${GIT_BRANCH_NAME}
      - GIT_COMMIT_HASH=${GIT_COMMIT_HASH}
      - GIT_LAST_COMMIT_MESSAGE=${GIT_LAST_COMMIT_MESSAGE}
      - BUILD_DATE=${BUILD_DATE}
      - GIT_DIRTY=${GIT_DIRTY}
     dockerfile: Dockerfile  # Ensure this points to your Dockerfile
    # image: jayeshire/mdv-frontend:latest
    ports:
      - "5055:5055"
      # - "5170:5170"
    volumes:
      # https://stackoverflow.com/questions/29181032/add-a-volume-to-docker-but-exclude-a-sub-folder
      # Volume isolation strategy:
      # - Mount source code from host for development (hot reload)
      # - Exclude build artifacts, dependencies, and virtual environments from host
      # - This prevents architecture conflicts and permission issues
      - .:/app
      - /app/venv/                    # Legacy venv directory (if any)
      - /app/python/.venv/            # Poetry virtual environment isolation
      - /app/docsenv/
      # subject to review - 'could not empty the output directory' errors etc...
      # - /app/docs/jsdocs/build/
      # - /app/docs/typedoc/
      # - /app/docs/maindocs/_build/
      # - /app/docs/maindocs/autoapi/
      - /app/node_modules/
      - /app/dist/
      - ~/mdv:/app/mdv
      # - ~/mdv:/root/mdv # XXX: so that scripts referring to '~/mdv/...' work - may still be issues with db integration etc...
      - ./app_logs:/app/logs
      # - ~/data:/app/data # thinking about allowing symlinked data folder...
    environment:
      # Flask configuration
      - FLASK_ENV=production  # Set environment to production
      - PYTHONUNBUFFERED=1  

      # Database connection details
      - DB_USER=my_db_user
      - DB_PASSWORD=my_db_password
      - DB_NAME=my_db_name
      - DB_HOST=mdv_db  # Assuming the db service name is mdv_db

      - FLASK_SECRET_KEY=abc
      - MDV_API_ROOT=/ # If the app is mounted at the root path, otherwise set to /mdv or similar

      # --- Authentication Configuration ---
      # For local development, authentication could be enabled by default using a "dummy" provider.
      # This allows testing protected endpoints without requiring real credentials.
      # The dummy provider automatically logs in a default user.
      # Right now, we'd need to add database migrations to make this work, so reverting to 0 for the time being.
      - ENABLE_AUTH=0
      - DEFAULT_AUTH_METHOD=dummy
      - LOGIN_REDIRECT_URL=/login_dev # Login route within the app

      # --- Example Auth0 Configuration ---
      # To use Auth0, set DEFAULT_AUTH_METHOD=auth0 and provide your credentials below.
      # - AUTH0_DOMAIN=your-auth0-domain.auth0.com
      # - AUTH0_CLIENT_ID=your-auth0-client-id
      # - AUTH0_CLIENT_SECRET=your-auth0-client-secret
      # - AUTH0_CALLBACK_URL=http://localhost:5055/callback
      # - AUTH0_AUDIENCE=https://your-api-audience.com
      # - AUTH0_PUBLIC_KEY_URI=https://your-auth0-domain.auth0.com/.well-known/jwks.json

      # --- Example Shibboleth Configuration ---
      # To use Shibboleth, set DEFAULT_AUTH_METHOD=shibboleth and configure your server
      # to provide the necessary Shibboleth headers. The URLs are for your IdP.
      # - SHIBBOLETH_LOGIN_URL=...
      # - SHIBBOLETH_LOGOUT_URL=...

    depends_on:
      - mdv_db

  mdv_pgadmin:
    image: dpage/pgadmin4
    ports:
      - "5054:5054"
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@mdv.com
      - PGADMIN_DEFAULT_PASSWORD=admin
      - PGADMIN_LISTEN_PORT=5054
    volumes:
      - pgadmin-data:/var/lib/pgadmin
    depends_on:
      - mdv_db

  mdv_db:
    image: postgres:16
    volumes:
      - postgres-data:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: my_db_user          # Hardcoded database user
      POSTGRES_PASSWORD: my_db_password    # Hardcoded database password
      POSTGRES_DB: my_db_name              # Hardcoded database name

volumes:
  postgres-data:
  mdv-data:
  pgadmin-data:

#secrets:
#  auth0_client_secret:
#    file: ./secrets/auth0_client_secret.txt